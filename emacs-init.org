#+Title: Emacs init file
#+Author: Shlomi Vaknin
* config                                                       :noexport:
  #+LANGUAGE:  en
  #+OPTIONS:   H:10 toc:t num:2
  #+PROPERTY:  header-args :padline no
  # + SETUPFILE: /Users/vaknins9/org/shlomi-bigblow.setup
  #+SETUPFILE: /Users/vaknins9/org/org-html-themes/setup/theme-bigblow-local.setup

  #+HTML_HEAD: <script> var HS_STARTUP_FOLDED = true; </script>
 
  
* Introduction
  Up until now I always used some /ready recipe/ for emacs, be it =Prelude=, =Emacs-live= or
  =Spacemacs=. All of them are awesome in their own way, but I really wanted my very own emacs
  configuration file, like a true emacs nerd.

  In order to step up emacsnerdiness even further, I decided to finally do it in org mode.  I still
  have everything in just one file divded into sections, perhaps when this grows larger I will
  seperate it into different files, not yet sure why.

  Instead of having plain top-level code to configure the various emacs packages, I am using the
  more modern, elegant and lazy =use-package= module, which makes package installation and setup much
  automated and more contained.
  
* Global                                                             :Macros:
  In this section I will put things that truely belong everywhere for themselves, such as this
  =comment= macro.

  #+BEGIN_SRC emacs-lisp :exports code :results silent
    (defmacro comment (&rest body)
    "Comment out one or more s-expressions."
    nil)
  #+END_SRC

  I was looking for a way to select major-mode based also on buffer name when it is not attached to
  a file. This is what I came up with, although more elegant ways might exist:
  #+BEGIN_SRC emacs-lisp :exports code :results silent
    (defmacro shlomi/buffer-name->major-mode (buffer-name-regex mjr-mode)
      `(setq-default major-mode
                     (lambda ()
                       (if (string-match-p ,buffer-name-regex (buffer-name))
                           ,mjr-mode
                         (fundamental-mode)))))

 
  #+END_SRC

  So, after not being fully satisfied with the above solution, I
  managed to find a [[http://emacs.stackexchange.com/a/2555/6847][much better solution]]:
  #+BEGIN_SRC emacs-lisp :exports code :results silent
  (setq-default major-mode
              (lambda () (if buffer-file-name
                          (fundamental-mode)
                            (let ((buffer-file-name (buffer-name)))
                          (set-auto-mode)))))
  #+END_SRC

* Performance
  Sometimes, while my emacs is up for a few days working through tramp
  and cider, I'd get insane lags for simple things such as moving the
  cursor. Profiling it showed that the GC was taking up lots of time
  (and also that =locate-dominating-file= was using over a gig of ram!!)

  A small help is to make the GC kick in a little later, instead of
  the default 800k, we could do at 500GiB, no? ;)

   #+BEGIN_SRC emacs-lisp :exports code :results silent
   ;;(setq gc-cons-threshold 500000000)
   #+END_SRC
  
* Network                                                           :Network:
  This section configures network for emacs. Proxy has to be set and unset, and [[https://www.emacswiki.org/emacs/TrampMode][=tramp=]] has to be
  configured. If your workflow involves using different machines, I highly recommend getting
  familiar with =tramp= and =~/.ssh/config=.

** Proxy settings                                                     :Proxy:
   Set up proxy configuration for use in intel network. 
   
   #+BEGIN_SRC emacs-lisp :exports code :results silent

     ;; Interactively enable/disable intel proxy
     (defun shlomi/intel-proxy-enable ()
       (interactive)
       (setq url-proxy-services
             '(("no_proxy" . "^\\(localhost\\|10.*\\)")
               ;;("http" . "proxy-us.intel.com:911")
               ;;("https" . "proxy-us.intel.com:911")
               )))

     (defun shlomi/intel-proxy-disable ()
       (interactive)
       (setq url-proxy-services '()))
   #+END_SRC

   #+BEGIN_tip
   Need to find a way to quickly tell if I am in an intel network.
   #+END_tip

   +Here is a simple attempt to see if I am on an intel network - check+
   +the hostname (need to see if this works in all cases)+

   #+BEGIN_SRC emacs-lisp :exports code :results silent
   (comment
     (defun shlomi/on-intel-network-p ()
       (string-suffix-p "intel.com" system-name)))
   #+END_SRC

   That hostname option did not work well. Instead lets try to see if the proxy address gets
   resolved to any ip - if it does, we are on an intel network.

   #+BEGIN_SRC emacs-lisp :exports code :results silent
     ;; if host is found, the process returns 0, if it does not, it returns 1
     (defun shlomi/on-intel-network-p ()
       (zerop (call-process-shell-command "host proxy-us.intel.com")))
   #+END_SRC

** Tramp                                                              :tramp:
   [[https://www.emacswiki.org/emacs/TrampMode][Tramp]] is one of the most powerful packages in emacs. It allows you to work on remote hosts as if
   they were local. Not only for editing files, but also to enable execution of commands on remote
   machines, working on their remot git through =magit=, and all as if they were local. Its a much
   more elegant idiom in my eyes than the tmux/vi combo, although it too has much merit.
   
     #+BEGIN_SRC emacs-lisp :exports code :results silent
     (require 'tramp)

     ;;; tramp defaults
     (add-to-list 'backup-directory-alist (cons tramp-file-name-regexp nil))
     (setq tramp-default-method "scp")

     ;; keep passwords
     (setq password-cache-expiry nil)

     ;; remote path 
     (add-to-list 'tramp-remote-path "/home/vaknins9/" "/home/vaknins9/bin")
     (add-to-list 'tramp-remote-path 'tramp-own-remote-path)

     (set-default 'tramp-default-proxies-alist (quote ((".*" "\\`root\\'" "/ssh:%h:"))))
   #+END_SRC

   It is especially convenient to have tramp parse =~/.ssh/config= file. This way you could access
   your servers just as you would by using =ssh= command, without having to specify all the
   connection parameters every time.
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     ;; Configure tramp to use ssh and parse .ssh/config file for convenience
     (tramp-set-completion-function "ssh"
      '((tramp-parse-sconfig "/etc/ssh_config")
        (tramp-parse-sconfig "~/.ssh/config")))
   #+END_SRC

   In order to identify where the file that we are editing is at, lets add to the mode-line a field
   that show us the hostname of the file's location, if its remote.
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     ;;; Status bar mods - if a file is remote, show where its at on the status bar
     (defconst my-mode-line-buffer-identification
       (list
        '(:eval
          (let ((host-name
                 (if (file-remote-p default-directory)
                     (concat
                      (propertize
                       (tramp-file-name-host (tramp-dissect-file-name default-directory))
                       'font-lock-face '(:foreground "light green" :weight bold)) ":")
                   "")))
            (if (string-match "^[^0-9][^.]*\\(\\..*\\)" host-name)
                (substring host-name 0 (match-beginning 1))
              host-name)))
        "%12b"))

     (setq-default mode-line-buffer-identification my-mode-line-buffer-identification)

     (add-hook
      'prog-mode-hook
      '(lambda ()
         (setq
          mode-line-buffer-identification
          my-mode-line-buffer-identification)))
   #+END_SRC

* Package management                                                :package:
  Emacs now has support for package managers. Package writers publish their packages to these repo's
  and all you have to do to install them is just to ask nicely.

  Lets configure the packages we are about to use. Note how I commented =melpa= out, that is because
  I got hurt too many times by unstable packages. Also, I intend to remove marmalade, since I only
  Use It For =auto-highlight-symbol=.
  #+BEGIN_SRC emacs-lisp :exports code :results silent
    (require 'package)
    (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/") t)
    ;;(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
    (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/") t)
    (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
    (add-to-list 'package-archives '("marmalade" . "https://marmalade-repo.org/packages/"))

    (package-initialize)
  #+END_SRC

  And lets set up proxy. This needs to somehow be conditioned on whether a proxy is needed or not.
  #+BEGIN_SRC emacs-lisp :exports code :results silent
    (when (shlomi/on-intel-network-p)
      (message "On an intel network, enabling proxy")
      (shlomi/intel-proxy-enable))
  #+END_SRC

  And lets now install =use-package= and configure what we can through it! Time to learn!  An
  important note about =use-package=, when you specify =:ensure t=, it downloads it from the repos
  and installs the package for you!
  #+BEGIN_SRC emacs-lisp :exports code :results silent
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))
  #+END_SRC

  From here on, everyone can use =package= functions such as =package-install=, although
  =use-package= makes it kinda redundant by using =:ensure t=, and more elegant. Use it if you can.
  
* UI                                                                     :ui:
** Themes                                                           :example:
   Here is a simple example of using =use-package=. The first argument is the package name, and the
   next are key/value pairs of keywords, such as =:ensure=, =:config= and =bind=:
     - =:ensure t= - invokes =package-install= if the package is not already installed
     - =:config= - an s-exp that gets invoked after the package is installed and loaded
     - =:bind= - a shortcut to define local and global keybindings
   
   Install zenburn theme from repo and activate it.
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package zenburn-theme
       :ensure t
       :config (load-theme 'zenburn t))
   #+END_SRC
** Fix up UI
   Lets remove welcome screen
   #+BEGIN_SRC emacs-lisp :exports code :results silent
   (setq inhibit-startup-screen t)
   #+END_SRC

   Also lets get rid of the tool-bar and scroll-bar
   #+BEGIN_SRC emacs-lisp :exports code :results silent
   (tool-bar-mode -1)
   (scroll-bar-mode -1)
   #+END_SRC

   And set up the frame title to show full file name
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (setq frame-title-format
           '("" invocation-name " Org-Init - " (:eval (if (buffer-file-name)
                                                 (abbreviate-file-name (buffer-file-name))
                                               "%b"))))
   #+END_SRC

   Stop the blinking cursor and disable the bell ring
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     ;; the blinking cursor is nothing, but an annoyance
     (blink-cursor-mode -1)

     ;; disable the annoying bell ring
     (setq ring-bell-function 'ignore)
   #+END_SRC

   Add line and column number, as well as the file size to the mode-line
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (line-number-mode t)
     (column-number-mode t)
     (size-indication-mode t)
   #+END_SRC

   We like to have a few words highlighted, such as =TODO:=, =BUG:= etc:
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (defun shlomi/highlight-words ()
       (font-lock-add-keywords nil '(("\\<\\(FIXME\\|TODO\\|BUG\\):" 1 font-lock-warning-face t))))
   #+END_SRC

   And lets attach this highligher to some modes:
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (add-hook 'prog-mode-hook 'shlomi/highlight-words)
     (add-hook 'lisp-mode-hook 'shlomi/highlight-words)
     (add-hook 'lisp-interaction-mode-hook 'shlomi/highlight-words)
     (add-hook 'org-mode-hook 'shlomi/highlight-words)
   #+END_SRC

   
** Highlight current line
   #+BEGIN_SRC emacs-lisp :exports code :results silent
   (global-hl-line-mode 1)
   (set-face-background 'hl-line  "#324d4d")
   #+END_SRC
** Interactively Do Things (ido)                                        :ido:
   [[https://www.emacswiki.org/emacs/InteractivelyDoThings][Ido]] is a comprehensive packge used to produce and utilize "auto-complete" suggestions which
   allows for a more interactive experience.

   Install it and activate it all over
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package ido
       :ensure t
       :config
       (progn
         (ido-mode t)
         (ido-everywhere)
         (setq ido-use-faces 't)
         (custom-set-faces
          '(ido-subdir 
            ((t (:foreground "LightGreen")))) ;; Face used by ido for highlighting subdirs in the alternatives.
          '(ido-first-match ((t (:foreground "Darkolivegreen3")))) ;; Face used by ido for highlighting first match.
          '(ido-only-match ((t (:foreground "#ffcc33")))) ;; Face used by ido for highlighting only match.
          '(ido-indicator ((t (:foreground "#ffffff")))) ;; Face used by ido for highlighting its indicators (don't actually use this)
          '(ido-incomplete-regexp ((t (:foreground "#ffffff")))))
         (setq ido-enable-flex-matching t)
         (setq ido-use-filename-at-point 'guess)))
   #+END_SRC
   
*** Ido vertical mode
    [[https://github.com/creichert/ido-vertical-mode.el][Ido vertical mode]] makes the list vertical rather than the default horisontal layout. This makes
    it much more readable and easy to navigate.
   #+BEGIN_SRC emacs-lisp :exports code :results silent
        (use-package ido-vertical-mode
	  :ensure t
          :config (progn
      	      (ido-vertical-mode 1)
   	      (setq ido-vertical-define-keys 'C-n-C-p-up-down-left-right)))
   #+END_SRC
   
*** ido ubiquitous
    /Does what =ido-everywhere= is supposed to do/

    This actually turns everything that is /auto-compleatable/ into an ido list. For example
    =cider-connect= now shows hosts and ports interactively.
    #+BEGIN_SRC emacs-lisp :exports code :results silent
      (use-package ido-ubiquitous
        :ensure t
        :config (ido-ubiquitous-mode 1))
    #+END_SRC
*** flx-ido
    This plugin provides fuzzy-matching for =ido=, and specifically =smex=. For example, this allows
    you to run =package-list-package= by only typing =M-x plp=
    #+BEGIN_SRC emacs-lisp :exports code :results silent
      (use-package flx-ido
        :ensure t
        :config (flx-ido-mode +1))
    #+END_SRC
** Auto-highlight-symbol
   Highlights symbols and lets you maneuver around the file using
   them 

   #+Begin_TIP
   This is the only package that requires marmalade, and I was
   told that marmalade should not be used, so I am considering simply
   adding this package locally..
   #+END_TIP
   
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package auto-highlight-symbol
       :ensure f
       :config (progn
                 (setq ahs-case-fold-search nil
                       ahs-default-range 'ahs-range-whole-buffer ;; start with scanning the entire buffer
                       ahs-idle-timer 10000000                   ;; Make the timer very long
                       ahs-idle-interval 100000000               ;; Make the timer very long
                       ahs-inhibit-face-list nil)

                 (defun prepare-ahs()
                   "Ensures that auto-highlight-mode is enabled and highlithing is active"
                   (auto-highlight-symbol-mode t)
                   (ahs-highlight-now))

                 ;; advice to start the mode and activate highlithing
                 (advice-add 'ahs-forward :before #'prepare-ahs)
                 (advice-add 'ahs-backward :before #'prepare-ahs)
                 (advice-add 'ahs-forward-definition :before #'prepare-ahs)
                 (advice-add 'ahs-backward-definition :before #'prepare-ahs)

                 ;; add cider/clojure modes to ahs's modes
                 (add-to-list 'ahs-modes 'cider-mode)
                 (add-to-list 'ahs-plugin-bod-modes 'cider-mode)
                 (add-to-list 'ahs-plugin-bod-modes 'clojure-mode)

                 ;; activate it globally
                 (global-auto-highlight-symbol-mode t)

                 ;; remove default bindings from mode-map
                 (define-key auto-highlight-symbol-mode-map (kbd "M-<left>" ) nil)
                 (define-key auto-highlight-symbol-mode-map (kbd "M-<right>" ) nil)
                 (define-key auto-highlight-symbol-mode-map (kbd "M-S-<left>" ) nil)
                 (define-key auto-highlight-symbol-mode-map (kbd "M-S-<right>" ) nil)
                 (define-key auto-highlight-symbol-mode-map (kbd "M--" ) nil)
                 (define-key auto-highlight-symbol-mode-map (kbd "C-x C-'" ) nil)
                 (define-key auto-highlight-symbol-mode-map (kbd "C-x C-a" ) nil)
                 (define-key auto-highlight-symbol-mode-map (kbd "<S-left>") nil))
       :bind (("C-."     . ahs-forward)
              ("C-,"     . ahs-backward)             
              ("C-x C-." . ahs-change-range)     
              ("C-s-/"   . ahs-edit-mode)          
              ("C-s-."   . ahs-forward-definition) 
              ("C-s-,"   . ahs-backward-definition)))

   #+END_SRC

** Control text scaling
   Often times we would like to quickly increase or decrease font size
   in buffer. I like it to be bound to =C-+= and =C--=
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (global-set-key (kbd "C-+") 'text-scale-increase)
     (global-set-key (kbd "C--") 'text-scale-decrease)
   #+END_SRC

** Rainbow Delimiters
   [[https://www.emacswiki.org/emacs/RainbowDelimiters][Rainbow delimiters]] package makes pretty parens appear with colors
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package rainbow-delimiters
       :ensure t
       :config (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
   #+END_SRC

   We would also like to highlight the matching paren
   #+BEGIN_SRC emacs-lisp :exports code :results silent
   (show-paren-mode 1)
   #+END_SRC
** Rainbow Identifier
   [[https://github.com/Fanael/rainbow-identifiers][Rainbow identifiers]] is a nifty little package that adds tons of colors to your source file
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package rainbow-identifiers
       :ensure t
       :config (add-hook 'prog-mode-hook 'rainbow-identifiers-mode))
   #+END_SRC
** Which-key
   [[https://github.com/justbur/emacs-which-key][Which-key]] is a great package for exploring and remembering key-bindings. At any point it can show
   what pressing more keys are bound to.

   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package which-key
       :ensure t
       :config (progn
                 (setq which-key-idle-delay 0.4)
                 (which-key-mode)

                 ;; location of which-key window. valid values: top, bottom, left, right,
                 ;; or a list of any of the two. If it's a list, which-key will always try
                 ;; the first location first. It will go to the second location if there is
                 ;; not enough room to display any keys in the first location
                 (setq which-key-side-window-location 'bottom)

                 ;; max width of which-key window, when displayed at left or right.
                 ;; valid values: number of columns (integer), or percentage out of current
                 ;; frame's width (float larger than 0 and smaller than 1)
                 (setq which-key-side-window-max-width 0.33)

                 ;; max height of which-key window, when displayed at top or bottom.
                 ;; valid values: number of lines (integer), or percentage out of current
                 ;; frame's height (float larger than 0 and smaller than 1)
                 (setq which-key-side-window-max-height 0.25)

                 (setq which-key-separator " ⟶ " )
                 (setq which-key-unicode-correction 3)))
   #+END_SRC
** Linum-relative
   Some times it is convenient to see relative line numbers, where the
   current line is always zero. [[https://github.com/coldnew/linum-relative][This package]] does just that.
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package linum-relative
       :ensure t
       :config (progn
                 (defun shlomi/linum-new-mode ()
                   "If line numbers aren't displayed, then display them.
                    Otherwise, toggle between absolute and relative numbers."
                   (interactive)
                   (if linum-mode
                       (linum-relative-toggle)
                     (linum-mode 1)))
            
                 (defun shlomi/linum-off-mode ()
                   "Toggles the line numbers as well as the fringe. This allows me
                    to maximize the screen estate."
                   (interactive)
                   (if linum-mode
                       (progn
                         (fringe-mode '(0 . 0))
                         (linum-mode -1))
                
                     (fringe-mode '(8 . 0))
                     (linum-mode 1)))) 
       :bind (("M-g o" . shlomi/linum-off-mode)
              ("M-g l" . shlomi/linum-new-mode)))
   #+END_SRC
** Pretty Mode-line
   [[http://emacs.stackexchange.com/questions/281/how-do-i-get-a-fancier-mode-line-that-uses-solid-colors-and-triangles][To really be fancy]], lets play around with =powerline= and later maybe some =smart-mode-line=
*** COMMENT Powerline
    #+BEGIN_SRC emacs-lisp :exports code :results silent
      (use-package powerline
        :ensure t
        :config (progn
                  (setq powerline-arrow-shape 'arrow)))
    #+END_SRC
*** Smart-mode-line
    #+BEGIN_SRC emacs-lisp :exports code :results silent
      (use-package smart-mode-line
        :ensure t
        :config (sml/setup))

      (use-package smart-mode-line-powerline-theme
        :ensure t)
    #+END_SRC
* Emacs-lisp
  Well, =Prelude= is in fact quite a nice emacs distribution, and so I shamelessly grabbed some
  stuff from it! The following functions are from prelude's emacs-lisp module.

  #+BEGIN_SRC emacs-lisp :exports code :results silent
    ;;(shlomi/buffer-name->major-mode  "\\.el\\'"  (emacs-lisp-mode))

    (define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-defun)
    (define-key emacs-lisp-mode-map (kbd "C-c C-b") 'eval-buffer)

    (comment (defun shlomi/emacs-lisp-mode-defaults ()
               "Sensible defaults for `emacs-lisp-mode'."
               (eldoc-mode +1)
               (shlomi/recompile-elc-on-save)
               (rainbow-mode +1)
               (setq mode-name "EL")))

    ;;    (setq emacs-lisp-mode-hook 'shlomi/emacs-lisp-mode-defaults)
  #+END_SRC
* Clojure
  The bestest language for the jvm, along with the bestest editor ever
  makes for the bestestest experience like EVER! :D
** Install Cider

   Lets set up [[https://github.com/clojure-emacs/cider][cider]] which is an awesome, fully-featured clojure ide in emacs.
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package cider
       :ensure t
       :config (setq nrepl-use-ssh-fallback-for-remote-hosts 't))
   #+END_SRC
** Prettify lambdas
  Makes some things look prettier 
  #+BEGIN_SRC emacs-lisp :exports code :results silent
    (defun lambda-as-lambda (mode ch pattern)
      (font-lock-add-keywords
       mode `((,pattern
               (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                         ,ch 'decompose-region)))))))
    ;; Setup lambdas
    (lambda-as-lambda 'clojure-mode "λ" "(\\(\\<fn\\>\\)")
    (lambda-as-lambda 'clojure-mode "λ" "(\\(fn\\)[\[[:space:]]")
    (lambda-as-lambda 'clojure-mode "ƒ" "\\(#\\)(")
    (lambda-as-lambda 'clojure-mode "∈" "\\(#\\){")
    (lambda-as-lambda 'emacs-lisp-mode  "λ" "(\\(\\<lambda\\>\\)")
  #+END_SRC

** Kill cider/nrepl buffers
   Occasionally, cider and nrepl will open up so many buffers, that it
   becomes a burden to close them all manually. So lets automate it:
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (defun shlomi/kill-all-cider-buffers ()
       (interactive)
       (mapcar 'kill-buffer
               (remove-if-not
                (lambda (x)
                  (string-match ".*cider.*" (buffer-name x)))
                (buffer-list))))

     (defun shlomi/kill-all-nrepl-buffers ()
       (interactive)
       (mapcar 'kill-buffer
               (remove-if-not
                (lambda (x)
                  (string-match ".*nrepl.*" (buffer-name x)))
                (buffer-list))))
   #+END_SRC
** Refactor clojure
   clj-refactor adds some really neat refactor functionality to clojure. Its quite
   impressive. However, I never really used it so maybe I should check it out..
   
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package clj-refactor
     :disabled
       :defer t
       :ensure t
       :config (progn
                 (clj-refactor-mode 1)
                 (cljr-add-keybindings-with-prefix "C-c C-SPC")))
   #+END_SRC

   #+BEGIN_warning
   I would use this, but my god! This imports a gazillion packages!! removed!
   #+END_warning

* Go
  Lets add some go support.
  #+BEGIN_SRC emacs-lisp :exports code :results silent
    (use-package go-mode
      :ensure t)
  #+END_SRC

* YAML
  Lots of configuations are now days defined as yaml. Lets use that.
  #+BEGIN_SRC emacs-lisp :exports code :results silent
    (use-package yaml-mode
      :ensure t)
  #+END_SRC
* Setup ctags
  Start bt getting ctags:
  #+BEGIN_SRC shell :exports code :results silent
  sudo apt-get install exuberant-ctags
  #+END_SRC

  Then, lets set it up:
  #+BEGIN_SRC emacs-lisp :exports code :results silent
  (setq path-to-ctags "/usr/bin/ctags") 
  (defun create-tags (dir-name)
    "Create tags file."
    (interactive "DDirectory: ")
    (shell-command
     (format "%s -f TAGS -e -R %s" path-to-ctags (directory-file-name dir-name))))
  #+END_SRC
* Conveniences
  Once you are used to some way of working, changing the habits is
  quite hard and not always truely justified. In this section I will
  be setting up lots of stuff to get the behaviour I want from emacs.

** Kill whole lines or region
   I am used to having =C-w= kill the current line and not current
   region! Lets fix this by having both operations: If a region is
   active, kill it, otherwise kill current line:
  #+BEGIN_SRC emacs-lisp :exports code :results silent
    (defun shlomi/kill-whole-line (&optional arg)
      "Copied from prelude:
       A simple wrapper around command `kill-whole-line' that respects indentation.
       Passes ARG to command `kill-whole-line' when provided."
      (interactive "p")
      (kill-whole-line arg)
      (back-to-indentation))

    (defun shlomi/kill-line-or-region ()
      "kill region if active only or kill line normally"
      (interactive)
      (if (region-active-p)
        (call-interactively 'kill-region)
        (call-interactively 'shlomi/kill-whole-line)))
  #+END_SRC

  And of couese, lets bind it:
  #+BEGIN_SRC emacs-lisp :exports code :results silent
  ;; conveniently kill region if one is active, if not, simply kill current line
  (global-set-key (kbd "C-w")   'shlomi/kill-line-or-region)
  #+END_SRC

** Stop using tabs
   Tabs are evil, please use spaces instead
   #+BEGIN_SRC emacs-lisp :exports code :results silent
   (setq-default indent-tabs-mode nil)
   #+END_SRC
** Easy-kill 
   [[https://github.com/leoliu/easy-kill][Easy-kill]] is a package that helps us control killing/marking etc.

   Lets install and set up easy-kill
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package easy-kill
       :ensure t
       :config (global-set-key [remap kill-ring-save] 'easy-kill))
   #+END_SRC
   
** Region Expand
   Super convenient tool to gradually expand a selection.

   Install and set up:
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package expand-region
       :ensure t
       :bind (("C-=". er/expand-region)))
   #+END_SRC

** Paredit
   Well smartparens really..
  
   Seriously, this is important. I will be using smartparens instead of
   paredit, but set the default configuration fo be identical to
   paredit.

   This package lets you work with parenthesis in a very structured
   way, without loosing your mind! yay for that!

   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package smartparens
     :ensure t
     :config (progn
           (sp-use-paredit-bindings)
           (add-to-list 'sp-ignore-modes-list 'org-mode)
           (smartparens-global-strict-mode 1)

           (sp-with-modes 'clojure-mode
             ;; disable ', it's the quote character!
             (sp-local-pair "'" nil :actions nil)
             (sp-local-pair "`" nil :actions nil)


             ;; also only use the pseudo-quote inside strings where it
             ;; serves as hyperlink.
             (sp-local-pair "`" "`" :when '(sp-in-string-p sp-in-comment-p))
             (sp-local-pair "'" "'" :when '(sp-in-string-p sp-in-comment-p)))
           ))
   #+END_SRC

   That last configuration, makes sure =clojure-mode= files will only pair =`= and ='= if in a comment or a string.

** Crux
   [[https://github.com/bbatsov/crux][Crux]] is a package containing many useful features, such as opening
   recent files, reopening files as root, etc.
      #+BEGIN_SRC emacs-lisp :exports code :results silent
        (use-package crux
          :ensure t
          :bind (("s-r" . crux-recentf-ido-find-file)
                 ("C-c C-r" . crux-recentf-ido-find-file)
                 ("C-a" . crux-move-beginning-of-line)))
   #+END_SRC

*** Recent files
    In order to get recent files working, we would need get package =recentf=:
    
    #+BEGIN_SRC emacs-lisp :exports code :results silent
      (use-package recentf
        :ensure t
        :config (progn
    	      (recentf-mode 1)
    	      (setq recentf-max-menu-items 25)))

    #+END_SRC

** Windmove - Move between open windows with shift
   Use shift+arrows to navigate between windows. Note, this does not work in org files!
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package windmove
       :config (when (fboundp 'windmove-default-keybindings)
      	   (windmove-default-keybindings)))
   #+END_SRC

** Add ace-window for easier window navigation
   Another way to navigate between windows, using ace-window. It
   numbers each window and lets you select the one you like
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package ace-window
       :ensure t
       :bind (("s-w" . ace-window)
              ("C-c C-o" . ace-window)))
   #+END_SRC

** avy navigation
   [[https://github.com/abo-abo/avy][avy package]] allows easy navigation for many things
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package avy
       :ensure t
       :bind (
   	   ("s-s" . avy-isearch)
   	   ("M-g M-g" . avy-goto-line)
   	   ("s-<up>" . avy-goto-line-above)
   	   ("s-<down>" . avy-goto-line-below)
   	   ("s-c" . avy-copy-line)
   	   ("s-M" . avy-move-line)
   	   ("s-d" . avy-copy-region) ;; not doing what I thought...
   	   ("s-SPC" . avy-goto-char)
   	   ("s-2" . avy-goto-char-2)
   	   ("s-1" . avy-goto-char)))
   #+END_SRC

** Company mode - autocomplete engine
   Complete anything.

   - There's some [[https://github.com/company-mode/company-mode/issues/218][bug with company-mode]] and eshell, where it simply replaces =*= with nothing.. Lets disable
     it for eshell major mode
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package company
       :ensure t
       :config (progn
                 (setq company-global-modes '(not eshell-mode))
                 (global-company-mode)))
   #+END_SRC

** Smart M-x, aka. smex
   shows possible emacs commands when hitting =M-x=
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package smex
       :ensure t
       :bind (("M-x" . smex)))
   #+END_SRC

** Multiple cursors
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package multiple-cursors
       :ensure t
       :bind (("C-;" . mc/mark-all-like-this)
              ("C-<" . mc/mark-previous-like-this)
              ("C->" . mc/mark-next-like-this)
              ("C-\"". mc/edit-lines)))
   #+END_SRC
** Yes or No shortcut
   Because why type three letters when you can type one??
   #+BEGIN_SRC emacs-lisp :exports code :results silent
   (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Delete highlighted text
   I often mark a region that I'd like to replace, this could be enabled via:
   #+BEGIN_SRC emacs-lisp :exports code :results silent
   (delete-selection-mode 1)
   #+END_SRC

** Projectile
   This package gets us a =project= context
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package projectile
       :ensure t
       :config (progn
                 (setq projectile-create-missing-test-files t)
                 (projectile-global-mode)))
   #+END_SRC
  
** Undo-tree
   [[https://www.emacswiki.org/emacs/UndoTree][Undo-tree]] package gives an incredible, fully branching undo mechanism. Very useful.
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package undo-tree
       :ensure t
       :config (global-undo-tree-mode))
   #+END_SRC

** Emacs backup files
   Emacs normally simply makes a =filename~= back-up file for every file you edit. This totally
   clutters up the system, and so, lets fix that!
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (setq version-control t     ;; Use version numbers for backups.
           kept-new-versions 10  ;; Number of newest versions to keep.
           kept-old-versions 0   ;; Number of oldest versions to keep.
           delete-old-versions t ;; Don't ask to delete excess backup versions.
           backup-by-copying t)  ;; Copy all files, don't rename them.

     (setq vc-make-backup-files t)

     ;; Default and per-save backups go here:
     (setq backup-directory-alist '(("" . "~/.emacs.d/backup/per-save")))

     (defun force-backup-of-buffer ()
       ;; Make a special "per session" backup at the first save of each
       ;; emacs session.
       (when (not buffer-backed-up)
         ;; Override the default parameters for per-session backups.
         (let ((backup-directory-alist '(("" . "~/.emacs.d/backup/per-session")))
               (kept-new-versions 3))
           (backup-buffer)))
       ;; Make a "per save" backup on each save.  The first save results in
       ;; both a per-session and a per-save backup, to keep the numbering
       ;; of per-save backups consistent.
       (let ((buffer-backed-up nil))
         (backup-buffer)))

     (add-hook 'before-save-hook  'force-backup-of-buffer)
   #+END_SRC

** Magit
   [[https://magit.vc/manual/2.7/magit/#Top][Magit]] package adds git support to emacs. 
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package magit
       :ensure t
       :bind (("C-x g" . magit-status)))
   #+END_SRC
** Hippie-expand
   [[https://www.emacswiki.org/emacs/HippieExpand][This nifty]] little package lets various things be expanded (i.e. completed, like with =tab=), from
   many different contexts, such as filenames etc.

   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package hippie-exp
       :ensure t
       :config (setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                                        try-expand-dabbrev-all-buffers
                                                        try-expand-dabbrev-from-kill
                                                        try-complete-file-name-partially
                                                        try-complete-file-name
                                                        try-expand-all-abbrevs
                                                        try-expand-list
                                                        try-expand-line
                                                        try-complete-lisp-symbol-partially
                                                        try-complete-lisp-symbol)))
   #+END_SRC
** Revert buffers
   If a buffer of a file is open, and the file changes in the file-system, we would like emacs to
   refresh the buffer to reflect whats on the file-syste.
   #+BEGIN_SRC emacs-lisp :exports code :results silent
   (global-auto-revert-mode t)
   #+END_SRC
** Various keybindings
   No need for =buffer-menu=:
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (global-set-key (kbd "C-x C-b") 'ibuffer)
   #+END_SRC
** Browse kill ring
   Emacs has not one clipboard, but a whole circular list of them, named ring. After you yank
   (paste) from the clipboard using =C-y=, you could use =M-y= to circularly rotate between items in
   the kill-ring. Occasionally it is convenient to browse that kill ring.

          :bind (:map browse-kill-ring-mode-map
                   ("C-g" . browse-kill-ring-quit))

   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package browse-kill-ring
       :ensure t
       :config (progn
                 (browse-kill-ring-default-keybindings)))
   #+END_SRC

* Org-mode
  Lets set up org-mode!
  #+BEGIN_SRC emacs-lisp :exports code :results silent
    (use-package org
      :config (progn
                ;; I rather have this key-binding do something else for now.
                ;; It used to cycle agenda files
                (define-key org-mode-map (kbd "C-," ) nil)

                ;; Lets start org-mode major mode for every buffer that ends with .org
                (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
                (setq org-todo-keywords '((sequence "TODO" "|" "IDEA" "DONE")))
                (setq org-todo-keyword-faces
                      '(("TODO" . org-warning) ("IDEA" . "Darkolivegreen4")
                        ("DONE" . (:foreground "DarkSeaGreen"  :weight bold)))))
      :bind (("C-c a"   . org-agenda)
             ("C-x C-n" . org-capture)
             ("\C-cl"   . org-store-link)
             ("\C-ca"   . org-agenda)
             ("\C-cb"   . org-iswitchb)))
  #+END_SRC

** Clock
   Org-mode supplies a wonderful mechanism to keep track of time. It
   can generate reports out of the tracked time as well.

   When it makes a report, all the times are summed up and showen as
   days, hours, minutes. However, instead of calculating days as 24
   hours period, lets treat a day as a 'work day', so a day is 8
   hours.  In previous versions of org-mode I actually had to changfe
   code to achieve this, but now there is an easy customization for it!

   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (setq org-duration-units `(("min" . 1)
                                ("h" . 60)
                                ("d" . ,(* 60 8))
                                ("w" . ,(* 60 8 5))
                                ("m" . ,(* 60 8 5 4))
                                ("y" . ,(* 60 8 5 4 10))))
     (org-duration-set-regexps)
   #+END_SRC

** Babel
   Babel is a tool that allows you to execute code in any language inside an =org= file, in fact,
   the code blocks used in this file are executed by babel!

*** Lets enable various languages
    #+BEGIN_SRC emacs-lisp :exports code :results none
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((ditaa . t)
         (R . t)
         (python . t)
         (C . t)
         (clojure . t)
         (emacs-lisp . t)
         (clojure . t)
         (shell . t)
         (gnuplot . t)))
    #+END_SRC

*** Configure Babel behavior
    - Control inline image behavior
      #+BEGIN_SRC emacs-lisp :exports code :results silent
        (setq org-image-actual-width 100)
      #+END_SRC

    - Stop asking me if I want to run a block, when I asked to run it
      #+BEGIN_SRC emacs-lisp :exports code :results silent
        (setq org-confirm-babel-evaluate 'nil)
      #+END_SRC

    - Fontify source blocks natively
      #+BEGIN_SRC emacs-lisp :exports code :results silent
        (setq org-src-fontify-natively t)
      #+END_SRC

    - Setup babel backends
      #+BEGIN_SRC emacs-lisp :exports code :results silent
        (setq org-babel-clojure-backend 'cider)
      #+END_SRC

    - Control tangling
      #+BEGIN_SRC emacs-lisp :exports code :results silent
        (add-to-list 'org-babel-tangle-lang-exts '("clojure" . "clj"))
      #+END_SRC
*** Configure ditaa
    [[http://ditaa.sourceforge.net/][ditaa]] is a nice ascii-art to image convertor. 
    #+BEGIN_SRC emacs-lisp :exports code :results silent
    (setq org-ditaa-jar-path "~/org-mode/org-mode/contrib/scripts/ditaa.jar")
    #+END_SRC
** Set up latex export
    - Configure tables export
    #+BEGIN_SRC emacs-lisp :exports code :results silent
    (setq org-latex-table-caption-above 'nil)
    (setq org-export-latex-table-caption-above 'nil)
    #+END_SRC

    - Add mint support
      #+BEGIN_SRC emacs-lisp :exports code :results silent
      (setq org-latex-listings 'minted)
      (add-to-list 'org-latex-packages-alist '("" "minted" nil))
      #+END_SRC

    - Configure latex processor
      #+BEGIN_SRC emacs-lisp :exports code :results silent
        (setq org-latex-pdf-process
      	'("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
      	  "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
      	  "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
      #+END_SRC
** Org Agenda and capture
   #+BEGIN_SRC emacs-lisp :exports code :results silent
    (setq org-capture-templates
          '(("t" "Todo" entry (file+headline "~/org//notes.org" "Tasks")
             "* TODO %?\n  %i\n  SCHEDULED: %T\n  %a")
            ("n" "Note on current clocked item" entry (clock)
             "* Note: %?\n  %i\n  %U\n  %a")
            ("j" "Journal" entry (file+datetree "~/org/journal.org")
             "* %?\nEntered on %U\n  %i\n  %a")
            ("h" "Home task" entry (file+headline "~/org/home.org" "Home")
             "* TODO  %? :tali:\n  %i\n  %U")
            ))
    
    (setq org-agenda-custom-commands
       '(("T" tags-todo "tali")))
   #+END_SRC

** Org-bullets-mode
   This makes org files a lot prettier
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package org-bullets
       :ensure t
       :config (add-hook 'org-mode-hook 'org-bullets-mode))
   #+END_SRC

** Custom block shortcuts
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (add-to-list 'org-structure-template-alist '("elr" "#+BEGIN_SRC emacs-lisp :exports results\n?\n#+END_SRC" "<src lang=\"?\">\n\n</src>"))
     (add-to-list 'org-structure-template-alist '("elc" "#+BEGIN_SRC emacs-lisp :exports code :results silent\n?\n#+END_SRC" "<src lang=\"?\">\n\n</src>"))
     (add-to-list 'org-structure-template-alist '("clj" "#+BEGIN_SRC clojure ?\n\n#+END_SRC" "<src lang=\"?\">\n\n</src>"))
     (add-to-list 'org-structure-template-alist '("cljc" "#+BEGIN_SRC clojure :exports code :results silent\n?\n#+END_SRC" "<src lang=\"?\">\n\n</src>"))
     (add-to-list 'org-structure-template-alist '("shc" "#+BEGIN_SRC sh :exports code :results silent\n?\n#+END_SRC" "<src lang=\"?\">\n\n</src>"))
     (add-to-list 'org-structure-template-alist '("t" "#+BEGIN_TIP\n?\n#+END_TIP" "<div class=\"tip\">\n\n</div>"))
     (add-to-list 'org-structure-template-alist '("w" "#+BEGIN_warning\n?\n#+END_warning" "<div class=\"warning\">\n\n</div>"))
     (add-to-list 'org-structure-template-alist '("n" "#+BEGIN_note\n?\n#+END_note" "<div class=\"note\">\n\n</div>"))
     (add-to-list 'org-structure-template-alist '("f" "#+BEGIN_info\n?\n#+END_info" "<div class=\"info\">\n\n</div>"))
   #+END_SRC
** Fix transpose-elements                                            :Advice:
   =org-transpose-elements= fails when invoked on plain words, I'd like it to simply invoke
   =org-transpose-words= when it fails. We could do that with an Advice
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (defun revert-to-transpose-words (orig-fun &rest args)
       (condition-case err
           (apply orig-fun args)
         (error 
          (apply 'org-transpose-words args))))

     (advice-add 'org-transpose-element :around #'revert-to-transpose-words)
   #+END_SRC
** Beginning of line                                                 :Advice:
   When moving to beginning of line =C-a=, it is often very convenient to first move to the first
   non-whitespace char in the line. It works elsewhere, lets add this functionality to org-mode as
   well

   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (defun toggle-beginning-of-line (orig-fun &rest args)
       "Move back to indentation first, then to beginning of line"
       (let ((initial-position (point)))
         (apply orig-fun args)
         (when (looking-at-p "^ +")
           (when (equal initial-position
                        (progn (back-to-indentation)
                               (point)))
             (beginning-of-line)))))

     (advice-add 'org-beginning-of-line :around #'toggle-beginning-of-line)
   #+END_SRC

** TODO Integrating with smartparens
   Org-mode does not play very well with lets, smartparens try to manually bind the useful stuff.
   Need to find a way to only enable parenthesis insertion withough any special key-bindings..
  
*** Configure gnuplot
    #+BEGIN_SRC emacs-lisp :exports code :results silent
      (use-package gnuplot :ensure t
        :config (progn
                  (require 'org-babel)
                  (require 'org-babel-init)
                  (require 'org-babel-gnuplot)))
    #+END_SRC
* Personal
** Fix tables for org-mode
   When I am using hadoop or spark, lots of their tables are delimited with tabs and are generally
   poorly formatted. This function fixes these table to an =org-table= format
   
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (defun shlomi/fix-tab-table (beg end)
       (interactive (if (use-region-p)
                        (list (region-beginning) (region-end))
                      (list nil nil)))
       (let* ((text (buffer-substring-no-properties beg end))
              (text (replace-regexp-in-string "\\(^\\)." "|" text nil nil 1))
              (text (replace-regexp-in-string ".\\($\\)" "|" text nil nil 1))
              (text (replace-regexp-in-string "\t" "|" text)))
         (delete-active-region)
    
         (string-match "^" text (string-match "|$" text))
         (insert (replace-match "|-\n" nil nil text))
         (when (eq major-mode 'org-mode)
           (org-table-align))
         ))
   #+END_SRC
** Update cluster ip
   When I am working on AWS, I would like to update =~/.ssh/config= file to represent the current
   master. The following function makes the update automatically for me:
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (defun shlomi/update-cluster-ip (ip)
       (interactive "snew ip:")
       (when (not (string= "" ip))
         (find-file "~/.ssh/config")
         (goto-char (point-min))
         (search-forward "ganglia")
         (search-forward "hostname")
         (kill-line)
         (insert " ")
         (insert ip)))
   #+END_SRC

** vimgolf
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package vimgolf :ensure t)
   #+END_SRC
** Share emacs session
*** Rudel
    well, this was way too complicated and simply does not work!
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     ;;(use-package rudel :ensure t)
   #+END_SRC

   So elpa the package manager has a super old version, lets try from the version in elpa the source code repository..
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     ;;(add-to-list 'load-path "~/emacs-git/elpa/")
     ;;(load-file "/Users/vaknins9/emacs-git/elpa/rudel-loaddefs.el")
   #+END_SRC

*** Togetherly
    [[https://github.com/zk-phi/togetherly/blob/master/Readme.org][Togetherly]] Seems to work just fine, and its much simpler
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (use-package togetherly
       :ensure t
       :disabled
       )
   #+END_SRC
   
   - To use it, start a server, specify IP, port and name.
   - From another emacs, start a client and specify to ip:port and a different name.

** Eshell configuration
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (defun eshell/x ()
       (insert "exit")
       (eshell-send-input)
       (delete-window))

     (defun eshell-here ()
       "Opens up a new shell in the directory associated with the
     current buffer's file. The eshell is renamed to match that
     directory to make multiple eshell windows easier."
       (interactive)
       (if (eq (with-current-buffer (current-buffer) major-mode) 'eshell-mode)
           (eshell/x)
           (let* ((parent (if (buffer-file-name)
                              (file-name-directory (buffer-file-name))
                            default-directory))
                  (height (/ (window-total-height) 3))
                  (name   (car (last (split-string parent "/" t)))))
             (split-window-vertically (- height))
             (other-window 1)
             (eshell "new")
             (rename-buffer (concat "*eshell: " name "*"))

             (insert (concat "ls"))
             (eshell-send-input))))

     (global-set-key (kbd "C-|") 'eshell-here)
   #+END_SRC

   I couldnt get eshell to set up the path. So instead of messing around with eshell for now, 
   I could simply start a process by invoking =sh -ec "app params"=
   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (defun eshell/run (app &rest args)
       (insert (format "sh -ec \"%s %s\"" app (mapconcat 'identity args " ")))
       (eshell-send-input))
   #+END_SRC
   
   And lets set up some default enviroment variables
   #+BEGIN_SRC emacs-lisp :exports code :results silent
   
   #+END_SRC

** Manipulating Colors
   Often when trying to mess around with colors, one might want to make a color ligher or darker. 
   The following functions are taken from [[http://www.recursivedream.com/blog/2015/incrementally-lightendarken-a-color-in-emacs][this awesome blog post]]:

   #+BEGIN_SRC emacs-lisp :exports code :results silent
     (defun lighten-color-at-point (&optional pct)
       (interactive "p")
       (unless (looking-at-p "#")
          (re-search-backward "#"))
       (save-excursion
         (push-mark nil t t)
         (let ((dist (skip-chars-forward "#A-Za-z0-9" (+ (point) 7)))
           (percent (or pct 5)))
           (insert (apply 'color-rgb-to-hex
             (apply 'color-hsl-to-rgb
               (apply 'color-lighten-hsl
                 (append (apply 'color-rgb-to-hsl
                   (color-name-to-rgb (buffer-substring-no-properties (mark) (point))))
                   (list percent))))))
         (delete-region (region-beginning) (+ (region-beginning) dist)))))

     (defun darken-color-at-point (&optional pct)
       (interactive "p")
       (lighten-color-at-point (if (numberp pct) (* pct -1) -5)))
   #+END_SRC
   
   To use it, position `point` inside a color string, such as
   ="#324d4d"=, and invoke either functions. The string will be
   replaced to the lighter/darker version of the color. 
** Flash executed s-exp
    This should have been eariler in this file, but when it is, I get a weird =Symbol’s value as variable is void: hi=. 
    Tried to look for it, but didnt find anything useful.. Sticking this here for the time being..
   
    Its always very convenient to have some visual feedback when you
    execute an s-exp, lets set it up with this:

    #+BEGIN_SRC emacs-lisp :exports code :results silent
      (use-package cider-eval-sexp-fu
        :ensure t
        :config (setq eval-sexp-fu-flash-duration 0.5))
    #+END_SRC
    

